{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
package org.usfirst.frc.team5141.robot;\'a0\
\
import edu.wpi.first.wpilibj.IterativeRobot;\
//import edu.wpi.cscore.UsbCamera;\
import edu.wpi.first.wpilibj.CameraServer;\
import edu.wpi.first.wpilibj.DriverStation;\
import edu.wpi.first.wpilibj.Encoder;\
import edu.wpi.first.wpilibj.GenericHID;\
import edu.wpi.first.wpilibj.SpeedControllerGroup;\
import edu.wpi.first.wpilibj.Joystick;\
import edu.wpi.first.wpilibj.SerialPort;\
import edu.wpi.first.wpilibj.Servo;\
import edu.wpi.first.wpilibj.drive.DifferentialDrive;\
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;\
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\
import edu.wpi.first.wpilibj.DigitalInput;\
import edu.wpi.first.wpilibj.Timer;\
import edu.wpi.first.wpilibj.VictorSP;\
import edu.wpi.first.wpilibj.Spark;\
import com.kauailabs.navx.frc.AHRS;\
import com.kauailabs.navx.frc.AHRS.SerialDataType;\
\
/**\
\'a0* The VM is configured to automatically run this class, and to call the\
\'a0* functions corresponding to each mode, as described in the IterativeRobot\
\'a0* documentation. If you change the name of this class or the package after\
\'a0* creating this project, you must also update the manifest file in the resource\
\'a0* directory.\
\'a0*/\
\
public class Robot extends IterativeRobot \{\
private static final String kDefaultAuto = "Default";\
private static final String kCustomAuto = "My Auto";\
private SendableChooser<String> m_chooser = new SendableChooser<>();\
\
DriverStation ds = DriverStation.getInstance();\
\
AHRS ahrs;\
Servo servo = new Servo(4);\
\
Joystick gamePad0 = new Joystick (0);\
Joystick gamePad1 = new Joystick (1);\
// double leftStickY = gamePad0.getRawAxis(1);\
// double rightStickY = gamePad0.getRawAxis(5);\
\
// VictorSP leftOne = new VictorSP(0);\
VictorSP leftTwo = new VictorSP(1);\
// VictorSP leftThree = new VictorSP(2);\
// SpeedControllerGroup leftDrive = new SpeedControllerGroup(leftOne, leftTwo, leftThree);\
SpeedControllerGroup leftDrive = new SpeedControllerGroup(leftTwo);\
// VictorSP rightOne = new VictorSP(3);\
VictorSP rightTwo = new VictorSP(7);\
// VictorSP rightThree = new VictorSP(5);\
// SpeedControllerGroup rightDrive = new SpeedControllerGroup(rightOne, rightTwo, rightThree);\
SpeedControllerGroup rightDrive = new SpeedControllerGroup(rightTwo);\
\
VictorSP elevator = new VictorSP(9);\
\
VictorSP intakeLeft = new VictorSP(6);\
VictorSP intakeRight = new VictorSP(5);\
SpeedControllerGroup intakeBoth = new SpeedControllerGroup(intakeLeft, intakeRight);\
\
VictorSP climber = new VictorSP(3); //\
VictorSP climbLift = new VictorSP(0); //the motor that extends the hook up\
\
Spark rgbLights = new Spark(2); //the Blinkin\
\
DifferentialDrive driveTrain = new DifferentialDrive(leftDrive, rightDrive);\
\
boolean confirmPath = false;\
\
// Compressor c = new Compressor(0);\
// Solenoid s0 = new Solenoid(0);\
// Solenoid s1 = new Solenoid(1);\
// Solenoid s2 = new Solenoid(2);\
\
/**If we had encoder code, again\
* Encoder enc;\
* enc = new Encoder(0, 1, false, Encoder.EncodingType.k4X);\
*\'a0\
*\'a0\
* enc.setMaxPeriod(.1);\
* Max Period: The maximum period (in seconds) where the device is still considered moving.\
*\'a0\
* enc.setMinRate(10);\
* Min Rate: Sets the minimum rate before the device is considered stopped.\
*\'a0\
* enc.setDistancePerPulse(5);\
* Distance Per Pulse: Sets the scale factor between pulses and distance.\
* 12334567\
* enc.setReverseDirection(true);\
* Reverse Direction: Sets the direction the encoder counts, used to flip the direction if the encoder mounting makes the default counting direction unintuitive.\
*\'a0\
* enc.setSamplesToAverage(7);\
* Sets the number of samples to average when determining the period.\
*\'a0\
* Resetting the Encoder\
*\'a0\
* enc.reset();\
*\'a0\
* Getting Encoder Values\
*\'a0\
* int count = enc.get();\
* Count: The current count. May be reset by calling reset().\
*\'a0\
* double rawCount = enc.getRaw();\
* Raw Count: The count without compensation for decoding scale factor.\
*\'a0\
* double distance = enc.getDistance();\
* Distance: The current distance reading from the counter. This is the count multiplied by the Distance Per Count scale factor.\
*\'a0\
* double period = enc.getPeriod();\
* Period: The current period of the counter in seconds. DEPRECATED USE RATE\
*\'a0\
* double rate = enc.getRate();\
* Rate: The current rate of the counter in units/sec.\'a0 It is calculated using the DistancePerPulse divided by the period.\
*\'a0\
* boolean direction = enc.getDirection();\
* Direction: The direction of the last value change (true for Up, false for Down).\
*\'a0\
* boolean stopped = enc.getStopped();\
* Stopped: If the counter is currently stopped (period has exceeded Max Period).\
*\'a0\
*\'a0\
*/\
\
int autoLoopCounter;\
int toggCount, toggCount1, toggCount2;\
boolean toggCount3;\
int toggIntake1 = 0;\
int toggIntake2 = 0;\
boolean adjustCube;\
\
int elevatorState; //Level Elevator is Physically At\
int elevatorDestiny; //Level Elevator Wants To Go\
String elevatorMode = "automatic";\'a0\
boolean elevatorTransition;\
\
double drive;\
double red = .61 ;\
double blue = .87;\
double gold = .67;\
boolean cToggCount = false;\
boolean cToggCount1 = false;\
boolean cToggCount2 = false;\
\
static double ERROR=0.5; //acceptable error for "t:" case. It will stop turning once it's within this amount of the target angle, basically.\
int i;\
boolean done;\
final int DIRECTION=-1;\
final double TURNTIME=1.5;\
final double MAX_NOTHING_SPEED_LEFT=0.3;\
final double MAX_NOTHING_SPEED_RIGHT=0.3;\
final double MAX_GOOD_SPEED=.15;\
final double MAX_NOTHING_ANGLE_SPEED_LEFT=.45;\
final double MAX_NOTHING_ANGLE_SPEED_RIGHT=.45;\
final double MAX_GOOD_ANGLE_SPEED=0.55; //this should be 1-.45 maximum (0.55)\
final double PROPORTION_LEFT=1;\
final double PROPORTION_RIGHT=1;\
final double RETRY_PROPORTION=2.5; //every time it goes past target angle, it divides the error by this number, so that decreases the speed. the higher the speed, the higher this number should be.\
final double RETRY_ATTEMPTS=3; //it will pass the target angle at least this many times ("unless it doesn't"), then won't stop until acceptable error is achieved.\
final int INTAKE_DIRECTION=1;\
double timeStart=0;\
double angleStart=0;\
double encoderStart=0;\
double g=0;\
int toggle=0;\
int toggleR2=0;\
int toggleL2=0;\
int toggleDont=0;\
double percentError2=0;\
int percentErrorPassCounter=0;\
double startAngle;\
double encRateToTankRate=DIRECTION*45/100.0;\
double BUFFER_DISTANCE=3;\
double distanceInchesL;\
double distanceInchesR;\
double targetAngle = 0;\
double targetTurnAmount;\
\
DigitalInput limitSwitch0 = new DigitalInput(2); //elevator at ground level\
DigitalInput limitSwitch1 = new DigitalInput(3); //elevator at switch level\
DigitalInput limitSwitch2 = new DigitalInput(4); //elevator at low scale level\
DigitalInput limitSwitch3 = new DigitalInput(5); //elevator at high scale level\
\
\
DigitalInput limitSwitch4 = new DigitalInput(1); //climberHook fully extended\
DigitalInput limitSwitch5 = new DigitalInput(0); //climberLift has climbed the bot to top\
Timer timer = new Timer();\
Timer elevatorTimer = new Timer();\
\
Encoder encLeft = new Encoder(6, 7);\
Encoder encRight = new Encoder(8, 9);\
\
\
/*GAME DEPENDENT VARIABLES ****************************************************************************************************************************\
*********************************** llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll*******************************************************************************************************************\
**************************************************************************************************************************************goblin**********\
*/\
char startPosition = 'L';\
\'a0 //If you place the bot on the left, type 'L' here; center, 'C'; right, 'R'\
char switchPosition;\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 //HOW DOES GAMEDATA WORK?! AGGHHHHH!!! 3/14/2018 4:34 PM ED\
char scalePosition;\
String destination = "Sw";\'a0 //If you're going for the switch, type "Sw"; scale, "Sc"\
/*****************************************************************************************************************************************************\
*****************************************************************************************************************************************************\
*/\
\
\
GenericHID.RumbleType rumble(double Output) \{\'a0\
return null;\
\}\
\
\
// public boolean solenoidAll(boolean aBoolean) \{\
// s0.set(aBoolean);\
// s1.set(aBoolean);\
// s2.set(aBoolean);\
// return false;\
// \}\
\
\
\'a0 \'a0 /**\
\'a0 \'a0 \'a0* This function is run when the robot is first started up and should be\
\'a0 \'a0 \'a0* used for any initialization code.\
\'a0 \'a0 \'a0*/\
\'a0 \'a0 public void robotInit() \{\
\'a0 \'a0 System.out.println("--- robotinit");\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 m_chooser.addDefault("Default Auto", kDefaultAuto);\
m_chooser.addObject("My Auto", kCustomAuto);\
SmartDashboard.putData("Auto choices", m_chooser);\
\'a0 \'a0 leftDrive.setInverted(true);\
\'a0 \'a0 rightDrive.setInverted(true);\
\'a0 \'a0 intakeRight.setInverted(true);\
\'a0 \'a0 elevator.setInverted(false);\
//\'a0 \'a0 UsbCamera camera = new UsbCamera("cam0",0);\
//\'a0 \'a0 camera.setFPS(15);\
\'a0 \'a0 CameraServer.getInstance().startAutomaticCapture();\
\'a0 \'a0 ahrs = new AHRS(SerialPort.Port.kMXP, SerialDataType.kProcessedData, (byte)50);\
\'a0 \'a0 rgbLights.set(0.13);\
\'a0 \'a0 encLeft.setDistancePerPulse(12/918.0); //This converts encoder pulses to inches.\
\'a0 \'a0 encRight.setDistancePerPulse(12/918.0);//12\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0\'a0\
\'a0 \'a0\'a0\
\'a0 \'a0 public String sameTurnary(char position) \{\
\'a0 \'a0 String value = "t:"+(position == 'L' ? "90" : "-90");\
\'a0 \'a0 return value;\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 public String differentTurnary(char position) \{\
\'a0 \'a0 String value = "t:"+(position == 'L' ? "-90" : "90");\
\'a0 \'a0 return value;\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0 /**\
\'a0 \'a0 \'a0* This function is run once each time the robot enters autonomous mode\
\'a0 \'a0 \'a0*/\
\'a0 \'a0 final String[] COMMANDLIST=\{\
//\'a0 \'a0 "e:2","w:.1","e:0"\
//\'a0 \'a0 "e:2"\
//\'a0 \'a0 "j:0","b:120"\
//\'a0 \'a0 "j:0","g:1","d:2","g:0","t:180","d:1"\
\};\
\'a0/*\'a0 \'a0final String[] COMMANDLIST_S_SW= \{\
//\'a0 \'a0 "j:0","b"\
\'a0 \'a0 "j:0","g:1","w:.5","g:0","b:120","g:1","e:2",sameTurnary(switchPosition),"g:0","b:6","g:-1","w:1","g:0"\
//\'a0 \'a0 "j:0","g:1","w:.5","g:0","b:2","g:1","e:2",sameTurnary(switchPosition),"g:0","b:0.5","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0 */\
\'a0 \'a0 final String[] COMMANDLIST_L_SW_L= \{\
//\'a0 \'a0 "e:2","w:.2","e:0"\
\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:120","g:1","e:2","t:90","g:0","b:6","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0 final String[] COMMANDLIST_R_SW_R= \{\
\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:120","g:1","e:2","t:-90","g:0","b:6","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
/*\'a0 \'a0final String[] COMMANDLIST_D_SW = \{\
//\'a0 \'a0 "j:0","b:120"\
\'a0 \'a0 "j:0","g:1","w:.5","g:0","b:200",differentTurnary(switchPosition),"b:145",differentTurnary(switchPosition),"e:6","w:3","b:18","g:-1","w:1","g:0"\
//\'a0 "j:0","g:1","w:.5","g:0","b:3",sameTurnary(switchPosition),"b:2",sameTurnary(switchPosition),"e:6","w:3","b:0.5","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0 */\
\'a0 \'a0 final String[] COMMANDLIST_L_SW_R = \{\
\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:220","t:90","b:155","t:90","e:4","w:3","b:18","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0 final String[] COMMANDLIST_R_SW_L = \{\
\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:220","t:-90","b:155","t:-90","e:4","w:3","b:18","g:-1","w:1","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0 final String[] COMMANDLIST_C = \{\
\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.2","g:0","e:2","b:100","g:-1"\
\'a0 \'a0 \};\
//\'a0 \'a0 final String[] COMMMANDLIST_C_SW_L = \{\
//\'a0 \'a0 "j:0","j:0","e:2","w:.2","e:0","g:1","w:.2","g:0","b:60","t:-90","b:84","t:90","b:50"\
//\'a0 \'a0 \};\
\'a0 \'a0\'a0\
\'a0 \'a0 final String[] COMMANDLIST_S_SC = \{\
//\'a0 \'a0 "j:0","b:120"\
//\'a0 \'a0 "j:0","g:1","w:.5","g:0","b:500","e:4","w:3",sameTurnary(switchPosition),"b:1","g:-1"\
\'a0 \'a0 \};\
\'a0 \'a0 final String[] COMMANDLIST_D_SC = \{\
//\'a0 \'a0 "j:0","b:120"\
//\'a0 \'a0 "j:0","g:1","w:.5","g:0","b:270",sameTurnary(scalePosition),"b:170",differentTurnary(scalePosition),"b:12","e:6","w:3",differentTurnary(scalePosition),"g:-1","w:.5","g:0"\
\'a0 \'a0 \};\
\'a0 \'a0\'a0\
\'a0 \'a0 //^This needs testing, maybe it will work great? 3/15 11:02 AM ED\
\'a0 \'a0\'a0\
\'a0 \'a0 public void autonomousInit() \{\
\'a0 \'a0\
\'a0 \'a0 System.out.println("--- autoinit");\
\
\'a0 \'a0 timer.reset();\
\'a0 \'a0 timer.start();\
\'a0 \'a0 elevatorDestiny=0;\
//\'a0 \'a0 c.setClosedLoopControl(false);\
\'a0 \'a0 rgbLights.set(0.13);\
\'a0 \'a0 ahrs.reset();\
\'a0 \'a0 String gameData="s";\
//\'a0 \'a0 do \{\
//\'a0 \'a0 gameData = DriverStation.getInstance().getGameSpecificMessage();\
//\'a0 \'a0 \}while(gameData.length()!=3);\
\'a0 \'a0\
\'a0 \'a0 while(gameData.length()<3) \{gameData = DriverStation.getInstance().getGameSpecificMessage();\}\
\'a0 \'a0 switchPosition = gameData.charAt(0);\
\'a0 \'a0 scalePosition = gameData.charAt(1);\
\'a0 \'a0 /*\
\'a0 \'a0 * Operations:\
\'a0 \'a0 * d=drive unit seconds\
\'a0 \'a0 * t=turn unit degrees from -180 to 180\
\'a0 \'a0 */\
\'a0 \'a0 done=false;\
\'a0 \'a0 i=0;\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0\
\'a0 \'a0\'a0\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0 public boolean commandRunner(String command) \{\
\'a0 \'a0 SmartDashboard.putNumber("Rate", DIRECTION*encLeft.getRate());\
\'a0 \'a0 double yaw=DIRECTION*ahrs.getYaw();\
\'a0 \'a0 //cuts below ;\
\'a0 \'a0 \'a0 \'a0 char operation=command.substring(0,command.indexOf(":")).charAt(0);\
\'a0 \'a0 \'a0 \'a0 //cuts after\
\'a0 \'a0 \'a0 \'a0 double value=Double.valueOf(command.substring(command.indexOf(":")+1));\
\'a0 \'a0 switch(operation) \{\
\'a0 \'a0 case 's'://stop\
\'a0 \'a0 driveTrain.stopMotor();\
\'a0 \'a0 driveTrain.tankDrive(-0.45*Math.signum(value)*DIRECTION,-0.45*Math.signum(value)*DIRECTION);//Stops Robot by driving in direction of value\'a0\
\'a0 \'a0 //driveTrain.tankDrive(-encLeft.getRate()*encRateToTankRate,-encLeft.getRate()*encRateToTankRate);\
\'a0 \'a0 return encLeft.getRate()<ERROR;\
\'a0 \'a0 case 'g':\'a0 \'a0//grab\
\'a0 \'a0 g=Math.signum(value)*.5;\
\'a0 \'a0 intakeBoth.set(g);//suck in direction of value\
\'a0 \'a0 return true;\
\'a0 \'a0 case 'w': // wait\
\'a0 \'a0 if(timeStart==0) \{\
\'a0 \'a0 timeStart=timer.get();//set timer to 0\'a0\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 if(timer.get()-timeStart>=value) \{\
\'a0 \'a0 commandRunner("r:0");//if done reset\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 case 'c':\
\'a0 \'a0 if (toggle ==0) \{\
\'a0 \'a0 servo.setAngle(value);//turn\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 boolean maybe=commandRunner("w:"+String.valueOf(TURNTIME));//wait till done\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 if (maybe||servo.getSpeed()==0) \{\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 case 'r': //reset\
\'a0 \'a0 timeStart=0;\
\'a0 \'a0 angleStart=0;\
\'a0 \'a0 toggle=0;\
\'a0 \'a0 percentError2=0;\
\'a0 \'a0 percentErrorPassCounter=0;\
\'a0 \'a0 yaw=0;\
\'a0 \'a0 encoderStart=0;\
\'a0 \'a0 distanceInchesL=0;\
\'a0 \'a0 encLeft.reset();\
\'a0 \'a0 return true;\
\'a0 \'a0 case 'e': //set elevator\
\'a0 \'a0 elevatorDestiny=(int) value;\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 return true;\
\'a0 \'a0 case 'j': // jolt\
\'a0 \'a0 if(toggle==0) \{\
\'a0 \'a0 timeStart=timer.get();\
\'a0 \'a0 //encoderStart=enc.getDistance();\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 if(timer.get()-timeStart<.19) \{\
\'a0 \'a0 \'a0 driveTrain.tankDrive(DIRECTION*.67,DIRECTION*.67);\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 else if(timer.get()-timeStart<.21) \{\
\'a0 \'a0 driveTrain.tankDrive(0,0);\
\'a0 \'a0 \}\
\'a0 \'a0 else if(timer.get()-timeStart<.49725) \{\
\'a0 \'a0 \'a0 driveTrain.tankDrive(-DIRECTION*.67,-DIRECTION*.67);\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 driveTrain.tankDrive(0, 0);\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0\
\'a0 \'a0 case 'd': //drive\
\'a0 \'a0 if(toggle==0) \{\
\'a0 \'a0 timeStart=timer.get();\
\'a0 \'a0 //encoderStart=enc.getDistance();\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 if(timer.get()-timeStart<Math.abs(value)) \{\
\'a0 \'a0 //double drive=MAX_GOOD_SPEED*DIRECTION;\
\'a0 \'a0 \'a0 driveTrain.tankDrive(Math.signum(value)*(DIRECTION*MAX_NOTHING_SPEED_LEFT+.1),Math.signum(value)*(DIRECTION*MAX_NOTHING_ANGLE_SPEED_RIGHT+.1));\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 /*\
\'a0 \'a0 * if(enc.getDistance()-ancoderStart<value-ERROR)\
\'a0 \'a0 * \{\
\'a0 \'a0 * double drive=MAX_GOOD_SPEED*DIRECTION;\
\'a0 \'a0 \'a0 driveTrain.tankDrive(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT,drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT);\
\'a0 \'a0 \'a0 double rate=enc.getRate()\
\'a0 \'a0 \'a0 SmartDashboard.putNumber("Rate left", rate);\
\'a0 \'a0 * \}\
\'a0 \'a0 */\
\'a0 \'a0 else \{\
\'a0 \'a0 driveTrain.tankDrive(0, 0);\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 break;\
\
\'a0 \'a0 case 'b': //drive\
\'a0 \'a0 if(Math.signum(ahrs.getYaw())==-1) \{\
\'a0 \'a0 targetAngle=0;\
\'a0 \'a0 ahrs.reset();\
\'a0 \'a0 \}\
\'a0 \'a0 if(toggle==0) \{\
\'a0 \'a0 encoderStart=encLeft.getRaw();\
\'a0 \'a0 targetAngle=targetAngle-1;\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 if(encLeft.getRaw()*.013 < value) \{ //Flash and Vanellope have different definitions of right and left motors\
\'a0 \'a0 //This makes me frown so hard, I'm smiling again.\
\'a0 \'a0 //double drive=MAX_GOOD_SPEED*DIRECTION;\
\'a0 \'a0 //  drive = drive * value > 130 ? -3.66 : 1;\
\'a0 \'a0 driveTrain.tankDrive(Math.signum(value)*(-.3+DIRECTION*MAX_NOTHING_SPEED_LEFT)-(normalizeAngle(normalizeAngle(ahrs.getYaw())-normalizeAngle(targetAngle)))/12,Math.signum(value)*(-.3+DIRECTION*MAX_NOTHING_ANGLE_SPEED_RIGHT));\
\'a0 \'a0 \'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 /*\
\'a0 \'a0 * if(enc.getDistance()-ancoderStart<value-ERROR)\
\'a0 \'a0 * \{\
\'a0 \'a0 * double drive=MAX_GOOD_SPEED*DIRECTION;\
\'a0 \'a0 \'a0 driveTrain.tankDrive(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT,drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT);\
\'a0 \'a0 \'a0 double rate=enc.getRate()\
\'a0 \'a0 \'a0 SmartDashboard.putNumber("Rate left", rate);\
\'a0 \'a0 * \}\
\'a0 \'a0 */\
\'a0 \'a0 else \{\
\'a0 \'a0 driveTrain.tankDrive(0, 0);\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 case 'm': // Drive according to encoder feedback\
\'a0 \'a0 if(toggle==0) \{\
\'a0 \'a0 timeStart=timer.get();\
\'a0 \'a0 startAngle = ahrs.getYaw();\
\'a0 \'a0 //encoderStart=enc.getDistance();\
\'a0 \'a0 toggle=1;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 if(encLeft.getDistance() < Math.abs(value))\{\
\'a0 \'a0 double drive=MAX_GOOD_SPEED*DIRECTION;\
\'a0 \'a0 if(encLeft.getDistance()<BUFFER_DISTANCE) \{\
\'a0 \'a0 driveTrain.tankDrive(\
\'a0 \'a0 \'a0 DIRECTION*Math.signum(value)*(Math.abs(encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_LEFT\
\'a0 \'a0 \'a0 +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0))\
\'a0 \'a0 \'a0 ,\
\'a0 \'a0 \'a0 DIRECTION*Math.signum(value)*(Math.abs(encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_RIGHT\
\'a0 \'a0 \'a0 -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)\
\'a0 \'a0 \'a0 ));\
\'a0 \'a0 \}\
\'a0 \'a0 else if(encLeft.getDistance()+BUFFER_DISTANCE<value) \{\
\'a0 \'a0 \'a0 driveTrain.tankDrive(\
\'a0 \'a0 \'a0 Math.signum(value)*((drive+DIRECTION*MAX_NOTHING_SPEED_LEFT)\
\'a0 \'a0 \'a0 +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0)),\
\'a0 \'a0 \'a0 Math.signum(value)*((drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT\
\'a0 \'a0 \'a0 -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0))\
\'a0 \'a0 \'a0 ));\
\'a0 \'a0 \'a0 //driveTrain.tankDrive(Math.signum(value)*(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT)+(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0)/(startAngle-ahrs.getYaw()),Math.signum(value)*(drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT+(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)));\
\'a0 \'a0 // Division is good between 20-15 Highscore Dante :23\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 else \{\
\'a0 \'a0 \'a0 driveTrain.tankDrive(\
\'a0 \'a0 \'a0 DIRECTION*Math.signum(value)*(Math.abs(Math.abs(value)-encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_LEFT\
\'a0 \'a0 \'a0 +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0))\
\'a0 \'a0 \'a0 ,\
\'a0 \'a0 \'a0 DIRECTION*Math.signum(value)*(Math.abs(Math.abs(value)-encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_RIGHT\
\'a0 \'a0 \'a0 -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)\
\'a0 \'a0 \'a0 ));\
\'a0 \'a0 \'a0\
\'a0 \'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 commandRunner("r:0");\
\'a0 \'a0 driveTrain.tankDrive(0,0);\
\'a0 \'a0 return true;\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0\
\'a0 \'a0 case 't': //turn\
\'a0 \'a0 if(toggle==0) \{\
\'a0 \'a0 angleStart=yaw;\
\'a0 \'a0 \}\
\'a0 \'a0\
double angle=yaw-angleStart; //so angle is the amount that you have turned since starting this "t" case\
double percentError=normalizeAngle(normalizeAngle(DIRECTION*value)-normalizeAngle(angle))/180; //percentError is how far off you are from your target\
boolean maybe=(Math.abs(percentError*180)>ERROR||Math.abs(percentError2*180)>ERROR);\
SmartDashboard.putNumber("angle", normalizeAngle(yaw+360-angleStart));\'a0\
SmartDashboard.putNumber("Zero difference angle", angleStart);\'a0\
SmartDashboard.putBoolean("maybe", maybe);\
if (toggle==1) \{percentErrorPassCounter=percentErrorPassCounter+(Math.signum(percentError)!=Math.signum(percentError2)?1:0);\}\
SmartDashboard.putNumber("percentError", percentError*180);\
SmartDashboard.putNumber("passed",percentErrorPassCounter);\
\
double er=percentError/Math.pow(RETRY_PROPORTION, percentErrorPassCounter);\
percentError2=percentError;\
\
\
\
\
/*if (!turnController.isEnabled()) \{\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 turnController.setSetpoint(180);\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 rotateToAngleRate = 0; // This value will be updated in the pidWrite() method.\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 turnController.enable();\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \}*/\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0\'a0\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 double leftStickValue = er*PROPORTION_LEFT;\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 double rightStickValue = er*PROPORTION_RIGHT;\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("er", er);\
\
\
if(percentErrorPassCounter<RETRY_ATTEMPTS||maybe||normalizeAngle(Math.abs(percentError-percentError)*180)>ERROR)\{\
double driveLeft=DIRECTION*Math.signum(leftStickValue)*(Math.abs(leftStickValue)*MAX_GOOD_ANGLE_SPEED+MAX_NOTHING_ANGLE_SPEED_LEFT);\
double driveRight=DIRECTION*Math.signum(rightStickValue)*(Math.abs(rightStickValue)*MAX_GOOD_ANGLE_SPEED+MAX_NOTHING_ANGLE_SPEED_RIGHT);\
SmartDashboard.putNumber("driveLeft", driveLeft);\
SmartDashboard.putNumber("driveRight", driveRight);\
\
\
driveTrain.tankDrive(driveLeft,-driveRight); //***************** 3/15 note: if bot turns and never stops correcting/wiggling, make driveLeft negative and driveRight positive.\
\
\}\
else \{\'a0\
driveTrain.tankDrive(0,0);\
commandRunner("r:0");\
targetAngle=targetAngle+value;\
return true;\
\}\
toggle=1;\
\
\'a0 \'a0 break;\
\'a0 \'a0 \}\
\'a0 \'a0 intakeBoth.set(g);\
\'a0 \'a0 return false;\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0 public static double normalizeAngle(double angle)\{\
\'a0 \'a0 return angle-360*Math.round(angle/360.0);\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0\'a0\
\'a0 \'a0 public static int factorial(int value)\{\
\'a0 \'a0 if(value==0) \{\
\'a0 \'a0 return 1;\
\'a0 \'a0 \}\
\'a0 \'a0 return factorial(value-1)*value;\
\'a0 \'a0 \}\
\
\'a0\'a0\
\'a0 \'a0 /**\
\'a0 \'a0 \'a0* This function is called periodically during autonomous\
\'a0 \'a0 \'a0*/\
\'a0 \'a0\'a0\
\'a0 \'a0 public void autonomousPeriodic() \{\
\'a0 \'a0\
\'a0 \'a0 System.out.println("--- autoperiodic");\
\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Yaw", ahrs.getYaw());\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Left Encoder Raw", encLeft.getRaw());\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Right Encoder Raw", encRight.getRaw());\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("startAngle",startAngle);\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Error", ahrs.getYaw() - startAngle);\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Left Distance", encLeft.getDistance());\
SmartDashboard.putNumber("Right Distance", encRight.getDistance());\
SmartDashboard.putNumber("elevatorDestiny", elevatorDestiny);\
SmartDashboard.putNumber("elevatorState", elevatorState);\
SmartDashboard.putNumber("targetAngle", targetAngle);\
String switchPos;\
if(switchPosition=='L') \{switchPos="L";\}\
else switchPos="R";\
String scalePos;\
if(scalePosition=='L') \{scalePos="L";\}\
else scalePos="R";\
SmartDashboard.putString("switchPos", switchPos);\
SmartDashboard.putString("scalePos", scalePos);\
distanceInchesL = encLeft.getRaw()*0.01363;\
SmartDashboard.putNumber("distanceInchesL", distanceInchesL);\
distanceInchesR = encRight.getRaw()*0.01363;\
SmartDashboard.putNumber("distanceInchesR", distanceInchesR);\
\'a0 \'a0 \'a0 \'a0 ahrs.enableLogging(true);\
\'a0 \'a0 \'a0 \'a0 if(elevatorDestiny > elevatorState && elevatorTransition) \{ //drive up toward destination\
elevator.set(1);\
\}\
if(elevatorDestiny < elevatorState && elevatorTransition) \{ //drive down toward destination\
elevator.set(-1);\
\}\
elevatorState = limitSwitch0.get()? elevatorState:0; //if you trip switch 0, you're at ground level\
\'a0 \'a0 elevatorState = limitSwitch1.get()? elevatorState:2; //if you trip switch 1, you're at Switch level\
\'a0 \'a0 elevatorState = limitSwitch2.get()? elevatorState:4; //if you trip switch 2, you're at Low Scale level\
\'a0 \'a0\
\'a0 \'a0 \'a0 \'a0 elevatorState = limitSwitch3.get()? elevatorState:6; //if you trip switch 3, you're at High Scale level\
\'a0 \'a0\
\
\'a0 \'a0 SmartDashboard.putNumber("elevatorState", elevatorState);\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 if(elevatorDestiny == elevatorState && elevatorTransition) \{ //stop when you get to the destination\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.start();\
\'a0 \'a0 elevator.set(0);\
\'a0 \'a0 elevatorTransition=false;\
\'a0 \'a0 \}\
\'a0 \'a0 if((elevatorDestiny == elevatorState && elevatorState != 0) && !elevatorTransition) \{ //hold elevator steady against gravity\
\'a0 \'a0 if(elevatorTimer.get()>0.01 && elevatorTimer.get()<.4) \{\
\'a0 \'a0 elevator.set(.1);\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 elevator.set(0);\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.start();\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.stop();\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 if (!done) \{\
\'a0 \'a0 \'a0 \'a0 try \{\
\'a0 \'a0 switch(startPosition) \{\
\'a0 \'a0 case 'L':\'a0\
\'a0 \'a0 if(destination == "Sw") \{\
\'a0 \'a0 if(switchPosition == 'L') \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_L_SW_L[i])?1:0);\
// \'a0 \'a0 i=i+(commandRunner(COMMANDLIST[i])?1:0);\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_L_SW_R[i])?1:0);\
//LScR\
\'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 \}\
\'a0 \'a0 if(destination == "Sc")\
\{\
\'a0 \'a0 if(scalePosition == 'L') \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_S_SC[i])?1:0);\
\'a0 \'a0 //LScL\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);\
\'a0 \'a0 //LScR\
\'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 \}\
\
\'a0 \'a0 case 'C':\'a0\
// \'a0 \'a0 if(destination == "Sw") \{\
// \'a0 \'a0 if(switchPosition == 'L') \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_C[i])?1:0);\
\'a0 \'a0 //CSw\
// \'a0 \'a0 \}\
// \'a0 \'a0 else \{\
// \'a0 \'a0 i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);\
// \'a0 \'a0 //CSwR\
// \'a0 \'a0 \}\
\'a0 \'a0 break;\
// \'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 case 'R':if(destination == "Sw") \{\
\'a0 \'a0 if(switchPosition == 'L') \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_R_SW_L[i])?1:0);\
\'a0 \'a0\
\'a0 \'a0 //RSwL\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 //RSwR\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_R_SW_R[i])?1:0);\
\'a0 \'a0\
\'a0 \'a0 break;\
\'a0 \'a0 \}\
\'a0 \'a0 if(destination == "Sc")\
\{\
\'a0 \'a0 if(scalePosition == 'L') \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);\
\'a0 \'a0 //RScL\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 i=i+(commandRunner(COMMANDLIST_S_SC[i])?1:0);\
\'a0 \'a0 //RScR\
\'a0 \'a0 \}\
\'a0 \'a0 break;\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}catch(IndexOutOfBoundsException r) \{\
\'a0 \'a0 \'a0 \'a0 SmartDashboard.putBoolean("Commands Done", true);\
done=true;\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 \'a0 \'a0 \}\
\'a0 \'a0 \}\
\
\'a0 \'a0\'a0\
\'a0 \'a0 \'a0/**This function is called once each time the robot enters tele-operated mode*/\
\'a0 \'a0\'a0\
\'a0 \'a0 public void teleopInit()\{\
\'a0 \'a0 System.out.println("--- teleopinit");\
//\'a0 \'a0 c.setClosedLoopControl(false);\
//\'a0 \'a0 s0.set(true);\
\'a0 \'a0 timer.reset();\
\'a0 \'a0 timer.start();\
\'a0 \'a0 ahrs.resetDisplacement();\
\'a0 \'a0 elevatorState=0;\
\'a0 \'a0 elevatorDestiny=0;\
\'a0 \'a0 encLeft.reset();\
\'a0 \'a0 encRight.reset();\
\'a0 \'a0 adjustCube = false;\
\'a0 \'a0\
\'a0 \'a0 \}\
\
\'a0 \'a0 /**\
\'a0 \'a0 \'a0* This function is called periodically during operator control\
\'a0 \'a0 \'a0*/\
\'a0 \'a0\'a0\
\'a0 \'a0 // Two controllers can't input to the same things at the same time, gamepad 0 has priority\
\'a0 \'a0 public void teleopPeriodic() \{\
\'a0 \'a0 \'a0 \'a0 System.out.println("--- teleopperiodic");\
\'a0 \'a0\
\'a0 \'a0 SmartDashboard.putNumber("toggIntake1", toggIntake1);\
\'a0 \'a0 SmartDashboard.putNumber("toggIntake2", toggIntake2);\
\'a0 \'a0 SmartDashboard.putBoolean("confirmPath", confirmPath);\
\'a0 \'a0 SmartDashboard.putNumber("Left Distance", encLeft.getDistance());\
\'a0 \'a0 SmartDashboard.putNumber("Right Distance", encRight.getDistance());\
\'a0 \'a0 SmartDashboard.putBoolean("getRawButtonPressed", gamePad0.getRawButton(10));\
\'a0 \'a0 SmartDashboard.putBoolean("cToggCount", cToggCount);\
\'a0 \'a0 SmartDashboard.putBoolean("limitSwitch0", limitSwitch0.get());\
\'a0 \'a0 SmartDashboard.putNumber("Left Encoder Raw", encLeft.getRaw());\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("Right Encoder Raw", encRight.getRaw());\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 //TESTING 1 2 3\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 SmartDashboard.putNumber("elevator", elevator.get());\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 SmartDashboard.putBoolean("confirmPath", confirmPath);\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 SmartDashboard.putBoolean("limitSwitch0", limitSwitch0.get());\
\'a0 \'a0 SmartDashboard.putBoolean("limitSwitch1", limitSwitch1.get());\
\'a0 \'a0 SmartDashboard.putBoolean("limitSwitch2", limitSwitch2.get());\
\'a0 \'a0 SmartDashboard.putBoolean("limitSwitch3", limitSwitch3.get());\
\'a0 \'a0 SmartDashboard.putNumber("elevatorState", elevatorState);\
\'a0 \'a0 SmartDashboard.putNumber("elevatorDestiny", elevatorDestiny);\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0\'a0\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0\'a0\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 distanceInchesL = encLeft.getRaw()*0.013;\
\'a0 \'a0 SmartDashboard.putNumber("distanceInchesL", distanceInchesL);\
\'a0 \'a0 distanceInchesR = encRight.getRaw()*0.013;\
\'a0 \'a0 SmartDashboard.putNumber("distanceInchesR", distanceInchesR);\
\'a0 \'a0 if(timer.get()>=105) \{rgbLights.set(.15);\}\
\'a0 \'a0 //SisterBot Code\
\'a0 \'a0 double rightStick = (gamePad0.getRawAxis(5) *.6)*(gamePad0.getRawAxis(3)+1);\'a0 \'a0 \'a0 //Drive Controls\
\'a0 \'a0 double leftStick = (gamePad0.getRawAxis(1) *.6)*(gamePad0.getRawAxis(3)+1);\'a0\
\'a0 \'a0 SmartDashboard.putNumber("leftStick",leftStick);\
\'a0 \'a0 SmartDashboard.putNumber("rightStick",rightStick);\
\'a0 \'a0 driveTrain.tankDrive(rightStick,leftStick); //rightStick, leftStick : Vanellope\
\'a0 \'a0 //\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 /* CompetitionBot Code\
\'a0 \'a0 double leftStick = (-gamePad0.getRawAxis(1) *.5)*(gamePad0.getRawAxis(3)+1);\'a0\
\'a0 \'a0 double rightStick = (-gamePad0.getRawAxis(5) *.5)*(gamePad0.getRawAxis(3)+1);\'a0\
\'a0 \'a0 driveTrain.tankDrive(DIRECTION*leftStick,DIRECTION*rightStick);\
\'a0 \'a0 */\
\'a0 \'a0\
\'a0 \'a0 //Climber\
\'a0 \'a0\
\'a0 \'a0 if(gamePad0.getPOV() == 90) \{\
\'a0 \'a0 adjustCube = true;\
\'a0 \'a0 intakeRight.set(.2);\
\'a0 \'a0 intakeLeft.set(-.2);\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 if(gamePad0.getPOV() == 270) \{\
\'a0 \'a0 adjustCube = true;\
\'a0 \'a0 intakeLeft.set(.2);\
\'a0 \'a0 intakeRight.set(-.2);\
\'a0 \'a0 \}\
\'a0 \'a0 /*\
\'a0 \'a0 if(gamePad0.getRawButton(5) && toggIntake1 == 0) \{//Intake\
\'a0 \'a0 /*if(intakeBoth.get()!=-.5) \{intakeBoth.set(-.5); toggIntake2 = 0;\} CompetitionBot\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 FIX\
\'a0 \'a0 \'a0\
\'a0 \'a0 if(intakeBoth.get()!=.5) \{intakeBoth.set(.5); toggIntake2 = 0;\} //SisterBot\
\'a0 \'a0 else \{intakeBoth.set(0); confirmPath = true;\}\
\'a0 \'a0 toggIntake1++;\
\'a0 \'a0 \}\
\'a0 \'a0 if(!gamePad0.getRawButton(5) && toggIntake1 == 1) \{\
\'a0 \'a0 toggIntake1 = 0;\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 \}//End of Intake\
\'a0 \'a0 */\
\'a0 \'a0\
\'a0 \'a0 if(gamePad0.getRawButton(5) && toggIntake2 == 0) \{//Input\
\'a0 \'a0\
\'a0 \'a0 if(intakeBoth.get()==0) \{intakeBoth.set(.5); toggIntake1 = 0;\} // .5 for CompBot\
\'a0 \'a0 else intakeBoth.set(0);\
\'a0 \'a0 toggIntake2++;\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0 if(!gamePad0.getRawButton(5) && toggIntake2 == 1) \{\
\'a0 \'a0 toggIntake2 = 0;\
\'a0 \'a0 \}//End of Output\
\'a0 \'a0\
\'a0 \'a0 if(gamePad0.getRawButton(6) && toggIntake1 == 0) \{//Output\
\'a0 \'a0 if(intakeBoth.get()==0) \{intakeBoth.set(-1); toggIntake2 = 0;\} // .5 for CompBot\
\'a0 \'a0 else intakeBoth.set(0);\
\'a0 \'a0 toggIntake1++;\
\'a0 \'a0 \}\
\'a0 \'a0 if(!gamePad0.getRawButton(6) && toggIntake1 == 1) \{\
\'a0 \'a0 toggIntake1 = 0;\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 //ELEVATOR\
\'a0 \'a0 if(gamePad0.getPOV()==0) \{\
\'a0 \'a0 elevatorMode = "manual";\
\'a0 \'a0 //intakeBoth.set(0);\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 elevator.set(elevatorState == 6 ? 0 : .5);\
\'a0 \'a0 elevatorDestiny = elevatorState;\
\'a0 \'a0 \}\
\'a0 \'a0 if(gamePad0.getPOV()==180) \{\
\'a0 \'a0 elevatorMode = "manual";\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 elevator.set(elevatorState == 0 ? 0 : -.5);\
\'a0 \'a0 elevatorDestiny = elevatorState;\
\'a0 \'a0 \}\
\'a0 \'a0 if(gamePad0.getPOV()==-1) \{\
\'a0 \'a0 elevatorMode = "automatic";\
\'a0 \'a0 if(adjustCube) \{\
\'a0 \'a0 intakeRight.set(0);\
\'a0 \'a0 intakeLeft.set(0);\
\'a0 \'a0 adjustCube=false;\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 //Climber\
\'a0 \'a0\
\'a0 \'a0 /*if(gamePad0.getRawButtonPressed(7)) \{\
\'a0 \'a0 cToggCount = !cToggCount;\
\'a0 \'a0 //climbLift.set(cToggCount ? 1 : 0); //does getRawButtonPressed just hate ternary?\
\'a0 \'a0 \}\
\'a0 \'a0 if(cToggCount) \{\
\'a0 \'a0 climbLift.set(1);\
\'a0 \'a0 \}\
\'a0 \'a0 */\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(7)) \{\
\'a0 \'a0 cToggCount=!cToggCount;\
\'a0 \'a0 if(cToggCount) \{\
\'a0 \'a0 climbLift.set(1);\
\'a0 \'a0 \}\
\'a0 \'a0 else climbLift.set(0); //getRawButtonPressed works\
\'a0 \'a0 \}\
\'a0 \'a0 /*if(gamePad0.getRawButtonPressed(8)) \{\
\'a0 \'a0 cToggCount1 = !cToggCount1;\
\'a0 \'a0 \}\
\'a0 \'a0 if(cToggCount1) \{\
\'a0 \'a0 climber.set(.75);\
\'a0 \'a0 climbLift.set(-1);\
\'a0 \'a0 \}\
\'a0 \'a0 */\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(8)) \{\
\'a0 \'a0 cToggCount1=!cToggCount1;\
\'a0 \'a0 if(cToggCount1) \{\
\'a0 \'a0 climber.set(.75);\
\'a0 \'a0 climbLift.set(-1);\
\'a0 \'a0 \}\
\'a0 \'a0 else climber.set(0); climbLift.set(0);\
\'a0 \'a0 \}\
\'a0 \'a0 /*\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(9)) \{ //for practice only. unwinds strap\
\'a0 \'a0 cToggCount2 = !cToggCount2;\
\'a0 \'a0 \}\
\'a0 \'a0 if(cToggCount2) \{\
\'a0 \'a0 climber.set(-.5);\
\'a0 \'a0 \}\
\'a0 \'a0 */\
\'a0 \'a0 if(limitSwitch5.get()==false) \{\
\'a0 \'a0 climber.set(0);\
\'a0 \'a0 \}\
\'a0 \'a0 if(limitSwitch4.get()==false) \{\
\'a0 \'a0 climbLift.set(0);\
\'a0 \'a0 \}\
\'a0 \'a0 if(!gamePad0.getRawButton(5) && toggCount2 == 1) \{\
\'a0 \'a0 \'a0 toggCount2 = 0;\
\'a0 \'a0 \}\
\'a0 \'a0 \'a0\'a0\
// \'a0 \'a0 if(gamePad0.getRawButton(6) && toggCount == 0) \{\
// \'a0 \'a0 s0.set(!s0.get());//S0 doesn't work without S2 going at the same time?\
// \'a0 \'a0 s1.set(!s1.get());// Gear pneumatics\
// \'a0 \'a0 s2.set(!s2.get());//\
// \'a0 \'a0 toggCount++;\
// \'a0 \'a0 \}\
\'a0 \'a0 if(!gamePad0.getRawButton(6) && toggCount == 1) \{\
\'a0 \'a0 toggCount = 0;\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 //BELOW ARE ELEVATOR CONTROLS\
\'a0 \'a0 //limit switches\
\'a0 \'a0\
\'a0 \'a0 //elevator code\
\'a0 \'a0 elevatorState = limitSwitch0.get()? elevatorState:0; //if you trip switch 0, you're at ground level\
\'a0 \'a0 elevatorState = limitSwitch1.get()? elevatorState:2; //if you trip switch 1, you're at Switch level\
\'a0 \'a0 elevatorState = limitSwitch2.get()? elevatorState:4; //if you trip switch 2, you're at Low Scale level\
\'a0 \'a0\
\'a0 \'a0 \'a0 \'a0 elevatorState = limitSwitch3.get()? elevatorState:6; //if you trip switch 3, you're at High Scale level\
\'a0 \'a0 if((elevator.get()-.1 > 0 && elevatorState == 4 && limitSwitch2.get())||(elevator.get() < 0 && elevatorState == 6 && limitSwitch3.get())/*||(elevatorState == 6 && limitSwitch3.get()==false)*/) \{ //if you are going up from switch 2 or coming down from switch 3, you\'e2\'80\'99re in between 2 and 3\
\'a0 \'a0 elevatorState = 5;\
\'a0 \'a0 \}\
\'a0 \'a0 if((elevator.get()-.1 > 0 && elevatorState == 2 && limitSwitch1.get())||(elevator.get() < 0 && elevatorState == 4 && limitSwitch2.get())/*||(elevatorState == 4 && limitSwitch2.get()==true)*/) \{ //if you are going up from switch 1 or coming down from switch 2, you\'e2\'80\'99re in between 1 and 2\'a0\
\'a0 \'a0 elevatorState = 3;\
\'a0 \'a0 \}\
\'a0 \'a0 if((elevator.get()-.1 > 0 && elevatorState == 0 && limitSwitch0.get())||(elevator.get() < 0 && elevatorState == 2 && limitSwitch1.get())/*||(elevatorState == 2 && limitSwitch1.get()==true)*/) \{ //if you are going up from switch 0 or coming down from switch 1, you\'e2\'80\'99re in between 0 and 2\
\'a0 \'a0 elevatorState = 1;\
\'a0 \'a0 confirmPath = true;\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 //Flip the polarity of comparators\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(1)) \{ //Press A to call elevator to ground level\
\'a0 \'a0 elevatorMode = "automatic";\
\'a0 \'a0 elevatorDestiny = 0;\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 \}\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(2)) \{ //Press B to call elevator to Switch Level\
\'a0 \'a0 elevatorMode = "automatic";\
\'a0 \'a0 elevatorDestiny = 2;\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 \}\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(3)) \{ //Press X to call elevator to low scale\
\'a0 \'a0 elevatorMode = "automatic";\
\'a0 \'a0 elevatorDestiny = 4;\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0 \}\
\'a0 \'a0 if(gamePad0.getRawButtonPressed(4)) \{ //Press Y to call elevator to high scale\
\'a0 \'a0 elevatorMode = "automatic";\
\'a0 \'a0 elevatorDestiny = 6;\
\'a0 \'a0 elevatorTransition=true;\
\'a0 \'a0\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0 if (elevatorMode == "automatic") \{\
\'a0 \'a0 if(elevatorDestiny > elevatorState) \{ //drive up toward destination\
\'a0 \'a0 elevator.set(1);\
\'a0 \'a0 \}\
\'a0 \'a0 if(elevatorDestiny < elevatorState) \{ //drive down toward destination\
\'a0 \'a0 elevator.set(-1);\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\
\
\
\
\
\'a0 \'a0 if(elevatorDestiny == elevatorState && elevatorMode == "automatic" && elevatorTransition) \{ //stop when you get to the destination\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.start();\
\'a0 \'a0 elevator.set(0);\
\'a0 \'a0 elevatorTransition=false;\
\'a0 \'a0 \}\
\'a0 \'a0\'a0\
\'a0 \'a0 boolean bouncy=false;\
\'a0 \'a0 if((elevatorDestiny == elevatorState && elevatorState != 0) && elevatorMode == "automatic"&&!elevatorTransition) \{ //hold elevator steady against gravity\
\'a0 \'a0 if(elevatorTimer.get()>0.01 && elevatorTimer.get()<.4) \{\
\'a0 \'a0 elevator.set(.1);\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 elevator.set(0);\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.start();\
\'a0 \'a0 \}\
\'a0 \'a0 bouncy=true;\
\'a0 \'a0 \}\
\'a0 \'a0 else \{\
\'a0 \'a0 elevatorTimer.reset();\
\'a0 \'a0 elevatorTimer.stop();\
\'a0 \'a0 \}\
\'a0 \'a0 \}\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0\
\'a0 \'a0 public static void main (String[] args) \{\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 Robot.main(args);\
\'a0 \'a0 \'a0 \'a0 \}\
\
\
\}\
\
\'a0 \'a0\
\'a0 \'a0 /**\
\'a0 \'a0 \'a0* This function is called periodically during test mode\
\'a0 \'a0 \'a0*/\
}